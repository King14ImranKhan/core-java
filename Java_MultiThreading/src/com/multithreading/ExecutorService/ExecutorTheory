Java Thread Pool
Java Thread pool represents a group of worker threads that are waiting for the job and reuse 
many times.
In case of thread pool, a group of fixed size threads are created. A thread from the thread 
pool is pulled out and assigned a job by the service provider. After completion of the job, 
thread is contained in the thread pool again.

Advantage of Java Thread Pool
Better performance and it saves time because there is no need to create new thread.

ExecutorService
Java 5 introduced a high-level API for concurrency, most of it implemented in the 
java.util.concurrent package.
Within ExecutorService we have 'Executors' Interface that provide an alternative(better) way to
launch and manage threads. 

submmit() vs execute()
The submit() method can accept both Runnable and Callable task but execute() can only accept 
the Runnable task.
The submit() method is declared in ExecutorService interface while execute() is declared in the
 Executor Interface.
The return type odd submit() method is a Future object but return type of execute() is void.


The execute() method is void and doesn't give any possibility to get the result of a task's 
execution or to check the task's status (is it running):
executorService.execute(runnableTask);

submit() submits a Callable or a Runnable task to an ExecutorService and returns a result of
type Future:
Future<String> future = executorService.submit(callableTask);

invokeAny() assigns a collection of tasks to an ExecutorService, causing each to run, and 
returns the result of a successful execution of one task (if there was a successful execution):
String result = executorService.invokeAny(callableTasks);

invokeAll() assigns a collection of tasks to an ExecutorService, causing each to run, and 
returns the result of all task executions in the form of a list of objects of type Future:
List<Future<String>> futures = executorService.invokeAll(callableTasks); 

The shutdown() method doesn't cause immediate destruction of the ExecutorService. It will make 
the ExecutorService stop accepting new tasks and shut down after all running threads finish 
their current work:
executorService.shutdown();

The shutdownNow() method tries to destroy the ExecutorService immediately, but it doesn't 
guarantee that all the running threads will be stopped at the same time:
List<Runnable> notExecutedTasks = executorService.shutDownNow();

The need for Callable

There are two ways of creating threads – one by extending the Thread class and other by 
creating a thread with a Runnable. However, one feature lacking in  Runnable is that we cannot
make a thread return result when it terminates, i.e. when run() completes. For supporting this
 feature, the Callable interface is present in Java.

Callable vs Runnable

For implementing Runnable, the run() method needs to be implemented which does not return 
anything, while for a Callable, the call() method needs to be implemented which returns a
result on completion. Note that a thread can’t be created with a Callable, it can only be 
created with a Runnable.
Another difference is that the call() method can throw an exception whereas run() cannot.


import java.util.Random; 
import java.util.concurrent.Callable; 
import java.util.concurrent.FutureTask; 
  
class CallableExample implements Callable 
{ 
  
    public Object call() throws Exception 
    { 
        // Create random number generator 
        Random generator = new Random(); 
  
        Integer randomNumber = generator.nextInt(5); 
  
        // To simulate a heavy computation, 
        // we delay the thread for some random time 
        Thread.sleep(randomNumber * 1000); 
  
        return randomNumber; 
    } 
} 


Future

When the call() method completes, answer must be stored in an object known to the main thread,
so that the main thread can know about the result that the thread returned. How will the 
program store and obtain this result later? For this, a Future object can be used. Think of a
Future as an object that holds the result – it may not hold it right now, but it will do so in
the future (once the Callable returns). Thus, a Future is basically one way the main thread can
keep track of the progress and result from other threads. To implement this interface,
5 methods have to be overridden, but as the example below uses a concrete implementation
from the library, only the important methods are listed here.

Observe that Callable and Future do two different things – Callable is similar to Runnable, in
that it encapsulates a task that is meant to run on another thread, whereas a Future is used
to store a result obtained from a different thread. In fact, the Future can be made to work 
with Runnable as well, which is something that will become clear when Executors come into the
 picture.

public boolean cancel(boolean mayInterrupt): Used to stop the task. It stops the task if it 
has not started. If it has started, it interrupts the task only if mayInterrupt is true.
public Object get() throws InterruptedException, ExecutionException: Used to get the result of
 the task. If the task is complete, it returns the result immediately, otherwise it waits till
  the task is complete and then returns the result.
public boolean isDone(): Returns true if the task is complete and false otherwise
To create the thread, a Runnable is required. To obtain the result, a Future is required.

The Java library has the concrete type FutureTask, which implements Runnable and Future,
 combining both functionality conveniently.
A FutureTask can be created by providing its constructor with a Callable. Then the FutureTask 
object is provided to the constructor of Thread to create the Thread object. Thus, indirectly,
the thread is created with a Callable. For further emphasis, note that there is no way to 
create the thread directly with a Callable.

Here is the code for the full example using Callable and FutureTask.

filter_none
edit
play_arrow

brightness_4
// Java program to illustrate Callable and FutureTask 
// for random number generation 
import java.util.Random; 
import java.util.concurrent.Callable; 
import java.util.concurrent.FutureTask; 
  
class CallableExample implements Callable 
{ 
  
  public Object call() throws Exception 
  { 
    Random generator = new Random(); 
    Integer randomNumber = generator.nextInt(5); 
  
    Thread.sleep(randomNumber * 1000); 
  
    return randomNumber; 
  } 
  
} 
  
public class CallableFutureTest 
{ 
  public static void main(String[] args) throws Exception 
  { 
  
    // FutureTask is a concrete class that 
    // implements both Runnable and Future 
    FutureTask[] randomNumberTasks = new FutureTask[5]; 
  
    for (int i = 0; i < 5; i++) 
    { 
      Callable callable = new CallableExample(); 
  
      // Create the FutureTask with Callable 
      randomNumberTasks[i] = new FutureTask(callable); 
  
      // As it implements Runnable, create Thread 
      // with FutureTask 
      Thread t = new Thread(randomNumberTasks[i]); 
      t.start(); 
    } 
  
    for (int i = 0; i < 5; i++) 
    { 
      // As it implements Future, we can call get() 
      System.out.println(randomNumberTasks[i].get()); 
  
      // This method blocks till the result is obtained 
      // The get method can throw checked exceptions 
      // like when it is interrupted. This is the reason 
      // for adding the throws clause to main 
    } 
  } 
} 


Daemon Thread


Daemon thread is a low priority thread that runs in background to perform tasks such as garbage
collection.

Properties:

They can not prevent the JVM from exiting when all the user threads finish their execution.
JVM terminates itself when all user threads finish their execution
If JVM finds running daemon thread, it terminates the thread and after that shutdown itself.
JVM does not care whether Daemon thread is running or not.
It is an utmost low priority thread.
Example-
// Java program to demonstrate the usage of  
// setDaemon() and isDaemon() method. 
public class DaemonThread extends Thread 
{ 
    public DaemonThread(String name){ 
        super(name); 
    } 
  
    public void run() 
    {  
        // Checking whether the thread is Daemon or not 
        if(Thread.currentThread().isDaemon()) 
        {  
            System.out.println(getName() + " is Daemon thread");  
        }  
          
        else
        {  
            System.out.println(getName() + " is User thread");  
        }  
    }  
      
    public static void main(String[] args) 
    {  
      
        DaemonThread t1 = new DaemonThread("t1"); 
        DaemonThread t2 = new DaemonThread("t2"); 
        DaemonThread t3 = new DaemonThread("t3"); 
      
        // Setting user thread t1 to Daemon 
        t1.setDaemon(true); 
              
        // starting first 2 threads  
        t1.start();  
        t2.start(); 
  
        // Setting user thread t3 to Daemon 
        t3.setDaemon(true);  
        t3.start();         
    }  
} 
